<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1475868278007">{:repl-history {:ide [], :local [&quot;(slurp \&quot;https://www.google.ru/search?q=123\&quot;)&quot; &quot;(slurp \&quot;http://www.google.com/search?q=123\&quot;)&quot; &quot;(slurp \&quot;https://www.google.com/search?q=123\&quot;)&quot; &quot;(defn sleep-print-update\n  [sleep-time thread-name update-fn]\n  (fn [state]\n    (Thread/sleep sleep-time)\n    (println (str thread-name \&quot;: \&quot; state))\n    (update-fn state)))\n(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 200 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 10 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 10 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 200 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))&quot; &quot;counter&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))&quot; &quot;(time\n  (do\n    (def counter (ref 0))\n    (future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n    (future (dosync (commute counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 150 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (commute counter (sleep-print-update 1000 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 1000 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 200 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 90 \&quot;Thread B\&quot; inc))))&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread B\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread B\&quot; inc))))\n&quot; &quot;(def counter (ref 0)) (future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc)))) (future (dosync (alter counter (sleep-print-update 100 \&quot;Thread B\&quot; inc))))\n&quot; &quot;(def counter (ref 0))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread A\&quot; inc))))\n(future (dosync (alter counter (sleep-print-update 100 \&quot;Thread B\&quot; inc))))&quot; &quot;(def receiver-1 (var #{}))&quot; &quot;(defn give-gift [giver-ref receiver-ref]\n  (let [gift (first @giver-ref)]\n    (commute receiver-ref conj gift)\n    (commute giver-ref disj gift)))&quot; &quot;(do\n  (future (wait 100 (give-gift giver receiver-1)))\n  (future (wait 100 (give-gift giver receiver-2))))&quot; &quot;(give-gift giver receiver-1)&quot; &quot;@receiver-1&quot; &quot;@receiver-2&quot; &quot;@giver&quot; &quot;(defn give-gift [giver-ref receiver-ref]\n  (let [gift (first @giver-ref)]\n    (alter receiver-ref conj gift)\n    (alter giver-ref disj gift)))&quot; &quot;(def receiver-1 (ref #{}))&quot; &quot;(def receiver-2 (ref #{}))&quot; &quot;(def giver (ref #{:gift}))&quot; &quot;(do\n  (future (dosync (wait 100 (give-gift giver receiver-1))))\n  (future (dosync (wait 100 (give-gift giver receiver-2)))))&quot; &quot;@receiver-1 @receiver-2 @giver&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def giver      (ref #{:gift}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (alter receiver-ref conj gift)\n      (alter giver-ref disj gift))))&quot; &quot;(dosync\n  (if-let [gift (first @giver-ref)]\n    (alter receiver-ref conj gift)\n    (alter giver-ref disj gift)))&quot; &quot;(dosync\n  (let [gift (first @giver)]\n    (alter receiver-1 conj gift)\n    (alter giver disj gift)))&quot; &quot;(dosync\n  (if-let [gift (first @giver)]\n    (alter receiver-1 conj gift)\n    (alter giver disj gift)))&quot; &quot;(if-let [gift (first @giver)]\n  (alter receiver-1 conj gift)\n  (alter giver disj gift))&quot; &quot;(if-let [a false]\n  a)&quot; &quot;(if-let [a true]\n  a)&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def giver (ref #{:gift}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def giver (ref #{:gift}))\n\n(do\n  (future (wait 10 (give-gift giver receiver-1)))\n  (future (wait 20 (give-gift giver receiver-2))))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def giver (ref #{:gift}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))\n\n(do\n  (future (wait 10 (give-gift giver receiver-1)))\n  (future (wait 20 (give-gift giver receiver-2))))\n\n@giver @receiver-1 @receiver-2&quot; &quot;@giver @receiver-1 @receiver-2&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def receiver-3 (ref #{}))\n(def giver (ref #{:gift1 :gift2}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))\n\n(do\n  (future (give-gift giver receiver-1))\n  (future (give-gift giver receiver-2))\n  (future (give-gift giver receiver-3)))\n\n@giver @receiver-1 @receiver-2 @receiver-3&quot; &quot;(first [])&quot; &quot;(seq [])&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def receiver-3 (ref #{}))\n(def giver (ref #{:gift1 :gift2}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first @giver-ref)]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))\n\n(do\n  (future (give-gift giver receiver-1))\n  (future (give-gift giver receiver-2))\n  (future (give-gift giver receiver-3)))&quot; &quot;(def receiver-1 (ref #{}))\n(def receiver-2 (ref #{}))\n(def receiver-3 (ref #{}))\n(def giver (ref #{:gift1 :gift2}))\n\n(defn give-gift [giver-ref receiver-ref]\n  (dosync\n    (if-let [gift (first (ensure giver-ref))]\n      (do\n        (alter receiver-ref conj gift)\n        (alter giver-ref disj gift)))))\n\n(do\n  (future (give-gift giver receiver-1))\n  (future (give-gift giver receiver-2))\n  (future (give-gift giver receiver-3)))&quot; &quot;@giver @receiver-1 @receiver-2 @receiver-3&quot; &quot;(use 'brave-true-clojure.concurrent)&quot; &quot;(give-gifts)&quot; &quot;(def *my-global* 42)&quot; &quot;(def ^:dynamic *my-global* 42)&quot; &quot;(binding [*my-global* 9001]\n  *my-global*)&quot; &quot;(binding [*my-global* 9001] *my-global*)&quot; &quot;*my-global*&quot; &quot;(binding [*my-global* 9001] (future *my-global*))&quot; &quot;(.name Thread/currentThread)&quot; &quot;(future (.getName (Thread/currentThread)))&quot; &quot;@(future (.getName (Thread/currentThread)))&quot; &quot;(dotimes\n  [n (.. Runtime (getRuntime) (availableProcessors))]\n  (future (.. Thread (currentThread) (getName))))&quot; &quot;(dotimes\n  [n (.. Runtime (getRuntime) (availableProcessors))]\n  (future (println (.. Thread (currentThread) (getName)))))&quot; &quot;(dotimes\n  [n (.availableProcessors (Runtime/getRuntime))]\n  (future (.getName (Thread/currentThread))))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future (swap! threads conj (.getName (Thread/currentThread))))))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future (swap! threads conj (.getName (Thread/currentThread)))))\n  (Thread/sleep 10)\n  threads)&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future (swap! threads conj (.getName (Thread/currentThread)))))\n  (Thread/sleep 10)\n  @threads)&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future (swap! threads conj (.getName (Thread/currentThread)))))\n  (Thread/sleep 10)\n  (sort @threads))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future \n      (swap! threads \n             conj \n             (str \&quot;future \&quot; n \&quot; on thread \&quot; (.getName (Thread/currentThread))))))\n  (Thread/sleep 10)\n  (sort @threads))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future \n      (swap! threads \n             conj \n             {:future n :thread (.getName (Thread/currentThread))})))\n  (Thread/sleep 10)\n  (sort @threads))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future \n      (swap! threads \n             conj \n             {:future n :thread (.getName (Thread/currentThread))})))\n  (Thread/sleep 10)\n  (sort-by :thread @threads))&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future \n      (swap! threads \n             conj \n             {:future n :thread (.getName (Thread/currentThread))})))\n  (Thread/sleep 10)\n  (sort-by :future @threads)\n  1\n  2)&quot; &quot;(let [threads (atom [])]\n  (dotimes\n    [n (.availableProcessors (Runtime/getRuntime))]\n    (future \n      (swap! threads \n             conj \n             {:future n :thread (.getName (Thread/currentThread))})))\n  (Thread/sleep 10)\n  (sort-by :future @threads))&quot; &quot;(map #(.getName (Thread/currentThread)) [1 2 3 4 5])&quot; &quot;(map #(str % \&quot; \&quot; (.getName (Thread/currentThread))) [1 2 3 4 5])&quot; &quot;(set (map (fn [_] (.getName (Thread/currentThread))) [1 2 3 4 5]))&quot; &quot;(.getName Thread/currentThread)&quot; &quot;(.getName (Thread/currentThread))&quot; &quot;(set (map (fn [_] (.getName (Thread/currentThread))) (vec (range 0 100000))))&quot; &quot;(set (pmap (fn [_] (.getName (Thread/currentThread))) (vec (range 0 100000))))&quot; &quot;(count \n  (set\n    (pmap (fn [_] (.getName (Thread/currentThread))) \n          (vec (range 0 100000)))))&quot; &quot;(count \n  (set\n    (map (fn [_] (.getName (Thread/currentThread))) \n          (vec (range 0 100000)))))&quot; &quot;(time\n  (count\n    (set\n      (map (fn [_] (.getName (Thread/currentThread)))\n           (vec (range 0 100000))))))&quot; &quot;(time\n  (count\n    (set\n      (pmap (fn [_] (.getName (Thread/currentThread)))\n           (vec (range 0 100000))))))&quot; &quot;(time\n  (count\n    (set\n      (pmap inc (vec (range 0 100000))))))&quot; &quot;(time\n  (count\n    (set\n      (map inc (vec (range 0 100000))))))&quot; &quot;(time\n  (count\n    (set\n      (map fac (vec (range 0 100000))))))&quot; &quot;(time\n  (count\n    (set\n      (map fac (vec (range 0 1000))))))&quot; &quot;(time\n  (count\n    (set\n      (map fac (vec (range 0 10000))))))&quot; &quot;(time (map fac (vec (range 0 10000))))&quot; &quot;(use 'brave-true-clojure.factorial)&quot; &quot;(time (map fac (vec (range 0 1000))))&quot; &quot;(binding [*print-length* 1]\n  (time (map fac (vec (range 0 1000)))))&quot; &quot;(binding [*print-length* 1]\n  (time (println (map fac (vec (range 0 1000))))))&quot; &quot;(binding [*print-length* 1]\n  (time (println (map fac (vec (range 0 2000))))))&quot; &quot;(binding [*print-length* 1]\n  (time (println (map fac (vec (range 0 5000))))))&quot; &quot;(binding [*print-length* 1]\n  (time (println (map fac (vec (range 0 9000))))))&quot; &quot;(binding [*print-length* 1]\n  (time (vec (map fac (vec (range 0 9000))))))&quot; &quot;(binding [*print-length* 1]\n  (time (println (vec (map fac (vec (range 0 9000)))))))&quot;], :remote []}}</component>
</project>